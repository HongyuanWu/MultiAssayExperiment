---
title: "MultiAssayExperiment toy example"
author: "Marcel Ramos, Levi Waldron"
date: "Oct 22, 2015"
output: 
  html_document: 
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
---

This vignette is the current working document for developing the
MultiAssayExperiment class and methods. See a built [html][] version.

Here is an overview of the design:

```{r}
suppressPackageStartupMessages(library(biocMultiAssay))
empty <- MultiAssayExperiment()
empty
slotNames(empty)
class(elist(empty))       #SimpleList
class(masterPheno(empty)) #data.frame
class(sampleMap(empty))   #list
## class(metadata(empty))    #NULL (class "ANY")
methods(class="MultiAssayExperiment")
```

Subsetting of samples and features is harmonized through some generic
functions:

```{r}
methods("featExtractor")
methods("sampleExtractor")
methods("subsetSample")
methods("subsetFeature")
```

# Generate toy data

In this example we have 4 patients, and a bit of metadata on them:
```{r}
masPheno <- data.frame(sex=c("M", "F", "M", "F"),
						  age=38:41,
						  row.names=c("Jack", "Jill", "Bob", "Barbara"))
masPheno
```

We have three matrix-like datasets.  First let's say expression data:

```{r, message=FALSE}
library(Biobase)
(arraydat <- matrix(seq(101, 108), ncol=4, dimnames=list(c("ENST00000294241", "ENST00000355076"), c("array1", "array2", "array3", "array4"))))
arraypdat <- as(data.frame(slope53=rnorm(4), row.names=c("array1", "array2", "array3", "array4")), "AnnotatedDataFrame")
exprdat <- ExpressionSet(assayData=arraydat, phenoData=arraypdat)
exprdat
```

The following map matches masterPheno sample names to exprdata sample
names.  Note that row orders aren't initially matched up.

```{r}
(exprmap <- data.frame(master=rownames(masPheno)[c(1, 2, 4, 3)],
					   assay=c("array1", "array2", "array3", "array4"), stringsAsFactors = FALSE))
```

Now methylation data.  It uses gene identifiers also, but measures a
partially overlapping set of genes.  For fun, let's store this as a
simple matrix. Also, it contains a replicate for one of the patients.

```{r}
(methyldat <- matrix(1:10, ncol=5, 
                     dimnames=list(c("ENST00000355076", "ENST00000383706"),
                                   c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"))))
```

The following map matches masterPheno sample names to methyldat sample
names.

```{r}
(methylmap <- data.frame(master = c("Jack", "Jack", "Jill", "Barbara", "Bob"),
                        assay = c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"), stringsAsFactors = FALSE))
```

Now we have a microRNA platform, which has no common identifiers.  It
is also missing data for Jill.  Just for fun, let's use the same
sample naming convention as we did for arrays.

```{r}
(microdat <- matrix(201:212, ncol=3, 
                    dimnames=list(c("hsa-miR-21", "hsa-miR-191", "hsa-miR-148a", "hsa-miR148b"), 
                                  c("micro1", "micro2", "micro3"))))
```

And the following map matches masterPheno sample names to microdat
sample names.

```{r}
(micromap <- data.frame(master = c("Jack", "Barbara", "Bob"),
                        assay = c("micro1", "micro2", "micro3"), stringsAsFactors = FALSE))
```

Let's include a `GRangesList`:  

```{r}
library(GenomicRanges)
gr1 <-
  GRanges(seqnames = "chr3", ranges = IRanges(58000000, 59502360), #completely encompasses ENST00000355076
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr3", "chr3"),
          ranges = IRanges(c(58493000, 3), width=9000), #first is within ENST0000035076
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
gr3 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(1, 4), c(3, 9)),
          strand = c("-", "-"), score = c(6L, 2L), GC = c(0.4, 0.1))
grl <- GRangesList("gr1" = gr1, "gr2" = gr2, "gr3" = gr3)
names(grl) <- c("snparray1", "snparray2", "snparray3")
grl
```

The following `data.frame` matches masterPheno sample to the
`GRangesList`:

```{r}
(rangemap <- data.frame(master = c("Jack", "Jill", "Jill"), 
						assay = c("snparray1", "snparray2", "snparray3"), stringsAsFactors = FALSE))
```

Adding the new `RangedSummarizedExperiment` class:

Create a `GenomicRangesList` object for the
`RangedSummarizedExperiment`:

```{r}
gg1 <-
  GRanges(seqnames = "chr2", ranges = IRanges(48000000, 49502360),
          strand = "-", score = 8L, GC = 0.95)
gg2 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(48493000, 30000), width=9000),
          strand = c("-", "+"), score = 6:7, GC = c(0.8, 1.0))
gg3 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(1, 4), c(3, 9)),
          strand = c("+", "+"), score = c(8L, 4L), GC = c(1.4, 1.1))
gg4 <- 
  GRanges(seqnames = c("chr1", "chr2"), 
          ranges = IRanges(c(1, 6), c(3, 9)),
          strand = c("+", "-"), score = 2.8, GC = c(0.3, 0.5))
grl2 <- GRangesList("grange1" = gg1, "grange2" = gg2, "grange3" = gg3, "grange4" = gg4)
names(grl2) <- c("mysnparray1", "mysnparray2", "mysnparray3", "mysnparray4")
```

```{r}
library(SummarizedExperiment)
numrows <- 4
numcols <- 4
counts <- matrix(runif(numrows * numcols, 1, 1e4), numrows)
colData <- DataFrame(Treatment=rep(c("ChIP", "Input"), 2),
                     row.names=c("Jack", "Jill", "Bob", "Barbara"))
rse <- SummarizedExperiment(assays=SimpleList(counts=counts),
                            rowRanges=grl2, colData=colData)
```

```{r}
(rangemap2 <- data.frame(master = c("Jack", "Jill", "Bob", "Barbara"), 
                        assay = c("mysnparray1", "mysnparray2", "mysnparray3", "mysnparray4"), stringsAsFactors = FALSE))
```

# Setup for creating the `MultiAssayExperiment` object
Create an ID map for all available experiments.  Names required, and must be identical to names of `elist`.

```{r}
idmap <- list(exprmap, methylmap, micromap, rangemap, rangemap2)
names(idmap) <- c("Affy", "Methyl 450k", "Mirna", "CNV gistic", "CNV gistic2")
idmap
```

Allowing for the possibility of ID maps entered as dataframes, convert
to conventional list:

```{r, message = FALSE}
library(reshape2) # reshape2 used for example only
dfmap <- melt(idmap, id.var = c("master", "assay"))
library(biocMultiAssay)
toListMap(dfmap, "L1")
```

Create an named list of experiments `objlist` for the MultiAssay function

```{r}
objlist <- list("Affy" = exprdat, "Methyl 450k" = methyldat, "Mirna" = microdat, "CNV gistic" = grl, "CNV gistic2" = rse)
```

# Create a `multiAssayExperiment` class object

```{r}
myMultiAssay <- MultiAssayExperiment(objlist, masPheno, idmap)
myMultiAssay
```

## Subsetting by Sample

Temporarily not evaluated due to bug ([Issue 53][]):

```{r, eval=FALSE}
logicID <- identifyBySample(myMultiAssay, 1:2)
logicID
subMultiAssay <- subsetBySample(myMultiAssay, logicID)
as.list(elist(subMultiAssay))
subsetByAssay(subMultiAssay, c(TRUE, FALSE, FALSE, FALSE), drop = TRUE)[[1]] %>% exprs 
subMultiAssay
```

Endogenous operation, returns a MultiAssay object containing elist of
length 1, map of length 1, and masterPheno for only Jack, Barbara, and
Bob.  The "Mirna" argument is used to index the `elist` object using
`[`, so could also be `integer` or `logical`:

```{r}
subsetByAssay(myMultiAssay, "Mirna", drop=FALSE)
```

Not endogenous, returns just the matrix contained in `elist$Mirna`

```{r}
subsetByAssay(myMultiAssay, "Mirna", drop=TRUE)
```

## Subsetting by Feature 

This operation returns a `MultiAssayExperiment` class, with any
`elist` element not containing the feature having zero rows.

Until we make subsetting by a gene ID work on ranges, the following
will return `c(TRUE, TRUE, FALSE, FALSE)`. When we implement
subsetting by ranges, it should return `c(TRUE, TRUE, FALSE, TRUE)`.

Returns `c(TRUE, TRUE, FALSE, FALSE)`:

```{r}
identifyByFeature(myMultiAssay, "ENST00000355076")  
```

Returns MultiAssayExperiment where `Affy` and `Methyl 450k` contain
only ENST0000035076 row, and "Mirna" and "CNV gistic" have zero rows:

```{r}
featSubsetted0 <- subsetByFeature(myMultiAssay, "ENST00000355076")
class(featSubsetted0)
class(elist(featSubsetted0))
as.list(elist(featSubsetted0))
```

In the following, `Affy` ExpressionSet keeps both rows but with their
order reversed, and `Methyl 450k` keeps only its second row.

```{r}
featSubsetted <- subsetByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"))
exprs(elist(myMultiAssay)[[1]])
exprs(elist(featSubsetted)[[1]])
```

## Identify assays that contain any / all of a vector of features

Note that the output of this function could be used as the input for
`subsetByAssay`.

```{r}
identifyByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"), requireall=FALSE) 
identifyByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"), requireall=TRUE) 
```

## Feature extraction by Ranges

See arguments to `GenomicRanges::subsetByOverlaps` for flexible types
of subsetting. The first two arguments are for subsetByFeature, the
rest passed on through "...":

```{r}
rangeSubset <- GRanges(seqnames = c("chr1"), strand = c("-", "+", "-"), ranges = IRanges(start = c(1, 4, 6), width = 3))
subsetted <- subsetByFeature(myMultiAssay, rangeSubset, maxgap = 2L, type = "within")
as.list(elist(subsetted))
```

### Auto-create sampleMap slot from data

```{r}
exprss1 <- matrix(rnorm(16), ncol = 4,
				 dimnames = list(sprintf("ENST00000%i", sample(288754:290000, 4)),
								 c("Jack", "Jill", "Bob", "Bobby")))
exprss2 <- matrix(rnorm(16), ncol = 4, 
				 dimnames = list(sprintf("ENST00000%i", sample(288754:290000, 4)),
								 c("Jack", "Jane", "Bob", "Bobby")))
doubleExp <- list("methyl 2k"  = exprss1, "methyl 3k" = exprss2)
(genMapMA <- MultiAssayExperiment(doubleExp, masPheno))
```
For now, fill the map with all observed samples: 

```{r}
sampleMap(MultiAssayExperiment(doubleExp, masPheno))
```

# Very next steps
* "mergeDups" function to merge duplicate samples in any assay
    + For matrix-like objects, it is clear how to do this. Default would be simple mean of the columns, but could allow user-specified functions.
    + For GRangesList, it's not obvious how to merge duplicates.  Just concatenate?

# Wishlist

* `c()` function for adding new assays to existing `MultiAssayExperiment`
    + e.g. c(myMultiAssay, neweset)
    + require that sample names in the new object match masterPheno sample names
    + require that sample names in the new object already exist in masterPheno

[html]: http://rpubs.com/lwaldron/biocmultiassaytoyexample
[Issue 53]: https://github.com/vjcitn/biocMultiAssay/issues/53
