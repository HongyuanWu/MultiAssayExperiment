---
title: "biocMultiAssayToyExample"
author: "Marcel Ramos, Levi Waldron"
date: "September 4, 2015"
output: html_document
---

# Generate toy data

In this example we have 4 patients, and a bit of metadata on them:
```{r}
masPheno <- data.frame(sex=c("M", "F", "M", "F"),
						  age=38:41,
						  row.names=c("Jack", "Jill", "Bob", "Barbara"))
masPheno
```

We have three matrix-like datasets.  First let's say expression data:

```{r, message=FALSE}
library(Biobase)
(arraydat <- matrix(seq(101, 108), ncol=4, dimnames=list(c("ENST00000294241", "ENST00000355076"), c("array1", "array2", "array3", "array4"))))
arraypdat <- as(data.frame(slope53=rnorm(4), row.names=c("array1", "array2", "array3", "array4")), "AnnotatedDataFrame")
exprdat <- ExpressionSet(assayData=arraydat, phenoData=arraypdat)
exprdat
```

The following map matches masterPheno sample names to exprdata sample names.  Note that row orders aren't initially matched up.
```{r}
(exprmap <- data.frame(master=rownames(masPheno)[c(1, 2, 4, 3)], assay=c("array1", "array2", "array3", "array4")))
```

Now methylation data.  It uses gene identifiers also, but measures a partially overlapping set of genes.  For fun, let's store this as a simple matrix. Also, it contains a replicate for one of the patients.

```{r}
(methyldat <- matrix(1:10, ncol=5, 
                     dimnames=list(c("ENST00000355076", "ENST00000383706"),
                                   c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"))))
```

The following map matches masterPheno sample names to methyldat sample names.

```{r}
(methylmap <- data.frame(master = c("Jack", "Jack", "Jill", "Barbara", "Bob"),
                        assay = c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5")))
```

Now we have a microRNA platform, which has no common identifiers.  It is also missing data for Jill.  Just for fun, let's use the same sample naming convention as we did for arrays.

```{r}
(microdat <- matrix(201:212, ncol=3, 
                    dimnames=list(c("hsa-miR-21", "hsa-miR-191", "hsa-miR-148a", "hsa-miR148b"), 
                                  c("micro1", "micro2", "micro3"))))
```

And the following map matches masterPheno sample names to microdat sample names.
```{r}
(micromap <- data.frame(master = c("Jack", "Barbara", "Bob"),
                        assay = c("micro1", "micro2", "micro3")))
```

Let's include a `GRangesList`:  

```{r}
library(GenomicRanges)
gr1 <-
  GRanges(seqnames = "chr3", ranges = IRanges(58000000, 59502360), #completely encompasses ENST00000355076
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr3", "chr3"),
          ranges = IRanges(c(58493000, 3), width=9000), #first is within ENST0000035076
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
gr3 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(1, 4), c(3, 9)),
          strand = c("-", "-"), score = c(6L, 2L), GC = c(0.4, 0.1))
grl <- GRangesList("gr1" = gr1, "gr2" = gr2, "gr3" = gr3)
names(grl) <- c("snparray1", "snparray2", "snparray3")
grl
```

The following `data.frame` matches masterPheno sample to the `GRangesList`: 

```{r}
(rangemap <- data.frame(master = c("Jack", "Jill", "Jill"), 
						assay = c("snparray1", "snparray2", "snparray3")))
```

Adding the new `RangedSummarizedExperiment` class:

Create a `GenomicRangesList` object for the `RangedSummarizedExperiment`:

```{r}
gg1 <-
  GRanges(seqnames = "chr2", ranges = IRanges(48000000, 49502360),
          strand = "-", score = 8L, GC = 0.95)
gg2 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(48493000, 30000), width=9000),
          strand = c("-", "+"), score = 6:7, GC = c(0.8, 1.0))
gg3 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(1, 4), c(3, 9)),
          strand = c("+", "+"), score = c(8L, 4L), GC = c(1.4, 1.1))
gg4 <- 
  GRanges(seqnames = c("chr1", "chr2"), 
          ranges = IRanges(c(1, 6), c(3, 9)),
          strand = c("+", "-"), score = 2.8, GC = c(0.3, 0.5))
grl2 <- GRangesList("grange1" = gg1, "grange2" = gg2, "grange3" = gg3, "grange4" = gg4)
names(grl2) <- c("mysnparray1", "mysnparray2", "mysnparray3", "mysnparray4")
```

```{r}
library(SummarizedExperiment)
nrows <- 4
ncols <- 4
counts <- matrix(runif(nrows * ncols, 1, 1e4), nrows)
colData <- DataFrame(Treatment=rep(c("ChIP", "Input"), 2),
                     row.names=c("Jack", "Jill", "Bob", "Barbara"))
rse <- SummarizedExperiment(assays=SimpleList(counts=counts),
                            rowRanges=grl2, colData=colData)
```

```{r}
(rangemap2 <- data.frame(master = c("Jack", "Jill", "Bob", "Barbara"), 
                        assay = c("mysnparray1", "mysnparray2", "mysnparray3", "mysnparray4")))
```

# Setup for creating the `MultiAssayExperiment` object
Create an ID map for all available experiments.  Names required, and must be identical to names of `elist`.

```{r}
idmap <- list(exprmap, methylmap, micromap, rangemap, rangemap2)
names(idmap) <- c("Affy", "Methyl 450k", "Mirna", "CNV gistic", "CNV gistic2")
idmap
```

Allowing for the possibility of ID maps entered as dataframes, convert to conventional list: 

```{r, message = FALSE}
library(reshape2) # reshape2 used for example only
dfmap <- melt(idmap, id.var = c("master", "assay"))
library(biocMultiAssay)
toListMap(dfmap)
```

Create an named list of experiments `objlist` for the MultiAssay function

```{r}
objlist <- list("Affy" = exprdat, "Methyl 450k" = methyldat, "Mirna" = microdat, "CNV gistic" = grl, "CNV gistic2" = rse)
```

# Create a `multiAssayExperiment` class object

```{r}
myMultiAssay <- MultiAssayExperiment(objlist, masPheno, idmap)
myMultiAssay
```

## Subsetting by Sample

```{r}
logicID <- identifyBySample(myMultiAssay, 1:2)
logicID
subMultiAssay <- subsetBySample(myMultiAssay, logicID)
as.list(elist(subMultiAssay))
subsetByAssay(subMultiAssay, c(TRUE, FALSE, FALSE, FALSE), drop = TRUE)[[1]] %>% exprs 
subMultiAssay
```

Endogenous operation, returns a MultiAssay object containing elist of length 1, map of length 1, and masterPheno for only Jack, Barbara, and Bob.  The "Mirna" argument is used to index the `elist` object using `[`, so could also be `integer` or `logical`:

```{r}
subsetByAssay(myMultiAssay, "Mirna", drop=FALSE)
```

Not endogenous, returns just the matrix contained in `elist$Mirna`

```{r}
subsetByAssay(myMultiAssay, "Mirna", drop=TRUE)
```

## Subsetting by Feature 

This operation returns a `MultiAssayExperiment` class, with any `elist` element not containing the feature having zero rows.

Until we make subsetting by a gene ID work on ranges, the following will return c(TRUE, TRUE, FALSE, FALSE). When we implement subsetting by ranges, it should return c(TRUE, TRUE, FALSE, TRUE). 

Returns c(TRUE, TRUE, FALSE, FALSE):
```{r}
identifyByFeature(myMultiAssay, "ENST00000355076")  
```

Returns MultiAssayExperiment where `Affy` and `Methyl 450k` contain only ENST0000035076 row, and "Mirna" and "CNV gistic" have zero rows:

```{r}
featSubsetted0 <- subsetByFeature(myMultiAssay, "ENST00000355076")
class(featSubsetted0)
class(elist(featSubsetted0))
as.list(elist(featSubsetted0))
```

In the following, `Affy` ExpressionSet keeps both rows but with their order reversed, and `Methyl 450k` keeps only its second row.

```{r}
featSubsetted <- subsetByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"))
as.list(elist(featSubsetted))
```
Reversed order:

```{r}
orderedSubset <- subsetByFeature(myMultiAssay, feature = c("ENST00000383706", "ENST00000355076", "ENST0000089383"))
elist(orderedSubset)[[2]]
```

## Identify assays that contain any / all of a vector of features

Note that the output of this function could be used as the input for `subsetByAssay`.
```{r}
identifyByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"), requireall=FALSE) 
identifyByFeature(myMultiAssay, c("ENST00000355076", "ENST00000294241"), requireall=TRUE) 
```

### Feature extraction by Ranges

Use `GenomicRanges::subsetByOverlaps`, passing its arguments to allow flexible types of subsetting. 

```{r}
rangeSubset <- GRanges(seqnames = c("chr1"), strand = c("-", "+", "-"), ranges = IRanges(start = c(1, 4, 6), width = 3))
subsetted <- subsetByFeature(myMultiAssay, rangeSubset, maxgap = 2L, type = "within")
as.list(elist(subsetted))
```

