---
title: "MultiAssayExperiment toy example"
author: "Marcel Ramos, Levi Waldron"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document: 
    number_sections: yes
    toc: yes
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
---

This vignette is the current working document for developing the
MultiAssayExperiment class and methods. See a built [html][] version.

Here is an overview of the design:

```{r}
suppressPackageStartupMessages(library(biocMultiAssay))
empty <- MultiAssayExperiment()
empty
slotNames(empty)
class(Elist(empty))       #Elist
class(pData(empty)) #DataFrame
class(sampleMap(empty))   #DataFrame
class(metadata(empty))    #NULL (class "ANY")
methods(class="MultiAssayExperiment")
methods(class="RangedRaggedAssay")
getMethod("colnames", "RangedRaggedAssay")
```

Subsetting of samples and features is harmonized through some generic
functions:

```{r}
methods("rownames") # features
methods("colnames") # samples
```

# Generate toy data

In this example we have 4 patients, and a bit of metadata on them:
```{r}
masPheno <- data.frame(sex=c("M", "F", "M", "F"),
						  age=38:41,
						  row.names=c("Jack", "Jill", "Bob", "Barbara"))
masPheno
```

We have three matrix-like datasets.  First let's say expression data:

```{r, message=FALSE}
library(Biobase)
(arraydat <- matrix(seq(101, 108), ncol=4, dimnames=list(c("ENST00000294241", "ENST00000355076"), c("array1", "array2", "array3", "array4"))))
arraypdat <- as(data.frame(slope53=rnorm(4), row.names=c("array1", "array2", "array3", "array4")), "AnnotatedDataFrame")
exprdat <- ExpressionSet(assayData=arraydat, phenoData=arraypdat)
exprdat
```

The following map matches pData sample names to exprdata sample
names.  Note that row orders aren't initially matched up.

```{r}
(exprmap <- data.frame(master=rownames(masPheno)[c(1, 2, 4, 3)],
					   assay=c("array1", "array2", "array3", "array4"), stringsAsFactors = FALSE))
```

Now methylation data.  It uses gene identifiers also, but measures a
partially overlapping set of genes.  For fun, let's store this as a
simple matrix. Also, it contains a replicate for one of the patients.

```{r}
(methyldat <- matrix(1:10, ncol=5, 
                     dimnames=list(c("ENST00000355076", "ENST00000383706"),
                                   c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"))))
```

The following map matches pData sample names to methyldat sample
names.

```{r}
(methylmap <- data.frame(master = c("Jack", "Jack", "Jill", "Barbara", "Bob"),
                        assay = c("methyl1", "methyl2", "methyl3", "methyl4", "methyl5"), stringsAsFactors = FALSE))
```

Now we have a microRNA platform, which has no common identifiers.  It
is also missing data for Jill.  Just for fun, let's use the same
sample naming convention as we did for arrays.

```{r}
(microdat <- matrix(201:212, ncol=3, 
                    dimnames=list(c("hsa-miR-21", "hsa-miR-191", "hsa-miR-148a", "hsa-miR148b"), 
                                  c("micro1", "micro2", "micro3"))))
```

And the following map matches pData sample names to microdat
sample names.

```{r}
(micromap <- data.frame(master = c("Jack", "Barbara", "Bob"),
                        assay = c("micro1", "micro2", "micro3"), stringsAsFactors = FALSE))
```

Let's include a `GRangesList`:  

```{r}
suppressPackageStartupMessages(library(GenomicRanges))
gr1 <-
  GRanges(seqnames = "chr3", ranges = IRanges(58000000, 59502360), #completely encompasses ENST00000355076
          strand = "+", score = 5L, GC = 0.45)
gr2 <-
  GRanges(seqnames = c("chr3", "chr3"),
          ranges = IRanges(c(58493000, 3), width=9000), #first is within ENST0000035076
          strand = c("+", "-"), score = 3:4, GC = c(0.3, 0.5))
gr3 <-
  GRanges(seqnames = c("chr1", "chr2"),
          ranges = IRanges(c(1, 4), c(3, 9)),
          strand = c("-", "-"), score = c(6L, 2L), GC = c(0.4, 0.1))
grl <- GRangesList("gr1" = gr1, "gr2" = gr2, "gr3" = gr3)
names(grl) <- c("snparray1", "snparray2", "snparray3")
grl
```

The following `data.frame` matches pData sample to the
`GRangesList`:

```{r}
(rangemap <- data.frame(master = c("Jack", "Jill", "Jill"), 
						assay = c("snparray1", "snparray2", "snparray3"), stringsAsFactors = FALSE))
```

Adding the new `RangedSummarizedExperiment` class:

Create a `GenomicRangesList` object for the
`RangedSummarizedExperiment`:

```{r}
library(SummarizedExperiment)
nrows <- 5; ncols <- 4
counts <- matrix(runif(nrows * ncols, 1, 1e4), nrows)
rowRanges <- GRanges(rep(c("chr1", "chr2"), c(2, nrows - 2)),
                     IRanges(floor(runif(nrows, 1e5, 1e6)), width=100),
                     strand=sample(c("+", "-"), nrows, TRUE),
                     feature_id=sprintf("ID\\%03d", 1:nrows))
names(rowRanges) <- letters[1:5]
colData <- DataFrame(Treatment=rep(c("ChIP", "Input"), 2),
                     row.names= c("mysnparray1", "mysnparray2", "mysnparray3", "mysnparray4"))
rse <- SummarizedExperiment(assays=SimpleList(counts=counts),
                            rowRanges=rowRanges, colData=colData)
```

```{r}
(rangemap2 <- data.frame(master = c("Jack", "Jill", "Bob", "Barbara"), 
                        assay = c("mysnparray1", "mysnparray2", "mysnparray3", "mysnparray4"), stringsAsFactors = FALSE))
```

# Setup for creating the `MultiAssayExperiment` object
Create an ID map for all available experiments.  Names required, and must be identical to names of `Elist`.

```{r}
listmap <- list(exprmap, methylmap, micromap, rangemap, rangemap2)
names(listmap) <- c("Affy", "Methyl 450k", "Mirna", "CNV gistic", "CNV gistic2")
listmap
```

Allowing for the possibility of ID maps entered as dataframes, convert
to conventional list:

```{r, message = FALSE}
dfmap <- biocMultiAssay:::.convertList(listmap)
toListMap(dfmap, "assayname")
```

Create an named list of experiments `objlist` for the MultiAssay function

```{r}
objlist <- list("Affy" = exprdat, "Methyl 450k" = methyldat, "Mirna" = microdat, "CNV gistic" = grl, "CNV gistic2" = rse)
```

# Create a `multiAssayExperiment` class object

```{r}
myMultiAssay <- MultiAssayExperiment(objlist, masPheno, dfmap)
myMultiAssay
Elist(myMultiAssay)
pData(myMultiAssay)
sampleMap(myMultiAssay)
metadata(myMultiAssay) 
```

# `rangedRaggedAssay` class

Note that the GRangesList got converted to a `rangedRaggedAssay`, which has some additional methods:

```{r}
class(Elist(myMultiAssay)[[4]])
rownames(Elist(myMultiAssay)[[4]])
colnames(Elist(myMultiAssay)[[4]])
assay(Elist(myMultiAssay)[[4]])
```

## Subsetting by Sample

```{r}
MultiAssayView_cl <- MultiAssayView(myMultiAssay, 2:1, "colnames")
MultiAssayView_cl
```

### Using a `MultiAssayView` class to subset
### TODO: Requires a different function for subsetting

```{r, eval = FALSE}
subMultiAssay <- subset(myMultiAssay, MultiAssayView_cl)
as.list(Elist(subMultiAssay))
subset(subMultiAssay, c(TRUE, FALSE, FALSE, TRUE, FALSE), "assays", drop = TRUE)[[1]] %>% exprs 
subMultiAssay
```

Endogenous operation, returns a MultiAssay object containing Elist of
length 1, map of length 1, and pData for only Jack, Barbara, and
Bob.  The "Mirna" argument is used to index the `Elist` object using
`[`, so could also be `integer` or `logical`:

```{r}
subset(myMultiAssay, "Mirna", "assays")
```

## Bracket operations 

The bracket method for the `MultiAssayExperiment` returns a specified subset of the data. 
The positions within the bracket operator, indicate `rownames`, `colnames`, and `assays` respectively. 
To subset by a particular assay, one can use this syntax: 

```{r}
myMultiAssay[,,"Mirna"]
```

## Subsetting by Feature 

This operation returns a `MultiAssayExperiment` class, with any
`Elist` element not containing the feature having zero rows.

Returns object of class `MultiAssayView`: 

```{r, eval = FALSE}
MultiAssayView(myMultiAssay, "ENST00000355076", "rownames")  
```

### Subset by rownames using the bracket `[` method
## TODO: Fix RangedRaggedAssay bug
```{r}
myMultiAssay["ENST00000355076",,]
```

Returns MultiAssayExperiment where `Affy` and `Methyl 450k` contain
only ENST0000035076 row, and "Mirna" and "CNV gistic" have zero rows:

### TODO: Fix evaluation with empty character(0)

```{r, eval = FALSE}
featSubsetted0 <- subset(myMultiAssay, MultiAssayView(myMultiAssay, "ENST00000355076", "rownames"))
class(featSubsetted0)
class(Elist(featSubsetted0))
Elist(featSubsetted0)
```

In the following, `Affy` ExpressionSet keeps both rows but with their
order reversed, and `Methyl 450k` keeps only its second row.

### Subsetting using MultiAssayView? 
```{r, eval=FALSE}
featSubsetted <- subset(myMultiAssay, MultiAssayView(myMultiAssay, c("ENST00000355076", "ENST00000294241"), "rownames"))
exprs(Elist(myMultiAssay)[[1]])
exprs(Elist(featSubsetted)[[1]])
```

## Identify and view assays that contain any of a vector of features

Note that the output of this function could be used as the input for
`subset`.

```{r, eval = FALSE}
MultiAssayView(myMultiAssay, c("ENST00000355076", "ENST00000294241"), "rownames") 
```

## Feature extraction by Ranges

See arguments to `GenomicRanges::subsetByOverlaps` for flexible types
of subsetting. The first two arguments are for `subset`, the
rest passed on through "...":

```{r, eval = FALSE}
rangeSubset <- GRanges(seqnames = c("chr1"), strand = c("-", "+", "-"), ranges = IRanges(start = c(1, 4, 6), width = 3))
subsetted <- subset(myMultiAssay, rangeSubset, "rownames", maxgap = 2L, type = "within")
Elist(subsetted)
```

## Subsetting by square bracket

Not yet working, eval=FALSE
```{r, eval=FALSE}
myMultiAssay[rangeSubset, , ]
myMultiAssay[c("ENST00000355076", "ENST00000294241"), , ]
myMultiAssay[, c("Jack", "Jill"), ]
```

```{r}
myMultiAssay[, , "Mirna"]
```

### Auto-create sampleMap slot from data

```{r}
exprss1 <- matrix(rnorm(16), ncol = 4,
				 dimnames = list(sprintf("ENST00000%i", sample(288754:290000, 4)),
								 c("Jack", "Jill", "Bob", "Bobby")))
exprss2 <- matrix(rnorm(16), ncol = 4, 
				 dimnames = list(sprintf("ENST00000%i", sample(288754:290000, 4)),
								 c("Jack", "Jane", "Bob", "Bobby")))
doubleExp <- list("methyl 2k"  = exprss1, "methyl 3k" = exprss2)
(genMapMA <- MultiAssayExperiment(doubleExp, masPheno))
```
For now, fill the map with all observed samples: 

```{r}
sampleMap(MultiAssayExperiment(doubleExp, masPheno))
```

# Validity checking of data classes

Any data classes in the Elist object must support the following methods:

* `colnames()`
* `rownames()`
* `assay()`    #to return experimental data
* `[`


Here is what happens if one of the methods doesn't:
```{r}
objlist2 <- objlist
objlist2[[2]] <- data.frame(objlist2[[2]])
invalid.obj <- try(MultiAssayExperiment(objlist2, masPheno, dfmap))
invalid.obj
```

# Very next steps
* Figure out how to support a "long-and-skinny" SQL database
* "mergeDups" function to merge duplicate samples in any assay
    + For matrix-like objects, it is clear how to do this. Default would be simple mean of the columns, but could allow user-specified functions.
    + For GRangesList, it's not obvious how to merge duplicates.  Just concatenate?


# Wishlist

* `c()` function for adding new assays to existing `MultiAssayExperiment`
    + e.g. c(myMultiAssay, neweset)
    + require that sample names in the new object match pData sample names
    + require that sample names in the new object already exist in pData

[html]: http://rpubs.com/lwaldron/biocmultiassaytoyexample
